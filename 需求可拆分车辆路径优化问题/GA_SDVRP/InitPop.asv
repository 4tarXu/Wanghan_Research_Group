function [TSPRoute,Chrom]=InitPop(NIND,CityNum,Demand,Capacity)
%% 初始化种群
%输入：
%NIND       种群大小
%CityNum	需求点个数
%Demand      各点需求量
%Capacity   车容量约束

%输出：
%Chrom      初始种群

Chrom=zeros(NIND,CityNum*3+1); %预分配内存，用于存储种群数据
TSPRoute= zeros(NIND,CityNum*2+1); %预分配内存，用于存储种群路径数据
for i=1:NIND
    TSProute=[0,randperm(CityNum)]+1; %随机生成一条不包括尾位的TSP路线
    VRProute=ones(1,CityNum*3+1); %初始化VRP路径
    delivery=0; % 汽车已经送货量，即已经到达点的需求量之和
    k=1;% k可以理解为一个指针，当前表示VRProute中第一个节点
    for j=2:CityNum+1
        k=k+1;   %对VRP路径下一点进行赋值
        if delivery+Demand(TSProute(j)) > Capacity %这一点配送完成后车辆可配送量超容量约束
            VRProute(k) = TSProute(j);  % 将当前循环中的客户节点放入路径中
            VRProute(k+1)=1; %将配送中心放入路径中
            % 以下就是本算法最精妙的地方：因为没有像ACO-SDVRP那样的剔除操作，所以本算法只是做了以下的车容量清空。
            delivery=Capacity-delivery - Demand(TSProute(j)); %新一辆车可配送量初始化，
            k=k+2;% 因为在此if循环中做了两次赋值，所以需要指针k直接跳转2次
            VRProute(k)=TSProute(j);  %TSP路线中此点添加到VRP路线
        else %
            delivery=delivery+Demand(TSProute(j)); %累加可配送量
            VRProute(k)=TSProute(j); %TSP路线中此点添加到VRP路线
        end
    end
    Chrom(i,1:length(VRProute))=VRProute;  %此路线加入种群
    TSPRoute(i,1:length(TSProute))=TSProute;
end